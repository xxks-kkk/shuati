# a data center is represented by a matrix, if matrix[j] = 1 then machine i and machine j are connected,
# if matrix[j] = 0, they are not connected. Right now, if a malware infected one machine,
# then it can spread to all the interconnected machines until there are no more reacheable machines to infect.
#
# You also know which machines are intial infected, but you only have enough time to fix a single one.
# Your goal is to choose the machine that will result in the maximum effect - defined as the largest difference
# in the final state of the data center if a single inital machine is repaired.
#
# return [which machine to fix, how many machine without infect due to the fix]
# example:
# [1 0 0]
# [0 1 0]
# [0 0 1]
# two infected machines [0, 1]
# result: [0, 1]
#
# method:  List<Integer> solution(List<List<Integer>> matrix, List<Integer> infectedMachines);
#
# Dropbox 2018 OA


def repair_machine(network, initial_machines):
    def dfs(i):
        count = 0
        for j in range(cols):
            if network[i][j] == 1 and visited[j] == 0:
                count += 1
                visited[j] = 1
                count += dfs(j)
        return count

    rows = len(network)
    cols = len(network[0])
    nMachines = len(initial_machines)
    # count[i] = # of machines infected when fix the machine i
    counts = [0 for _ in range(nMachines)]
    visited = [0 for _ in range(rows)]
    totalCount = 0
    for machine in initial_machines:
        if visited[machine] == 0:
            totalCount += dfs(machine)
    visited = [0 for _ in range(rows)]
    for i in range(nMachines):
        test_list = list(range(0, i)) + list(range(i + 1, nMachines))
        # test_list_machines = []
        # for j in test_list:
        #     # we want to skip the machines fall within the same connected components because
        #     # otherwise fix initial_machines[i] will fix initial_machines[j] if both machines are in the same group.
        #     # Consider the last test case as an example.
        #     if network[initial_machines[i]][initial_machines[j]] != 1:
        #         test_list_machines.append(j)
        test_list_machines = [initial_machines[i] for i in test_list]
        for machine in test_list_machines:
            if visited[machine] == 0:
                counts[i] += dfs(machine)
        visited = [0 for _ in range(rows)]
    res = [0, totalCount - counts[0]]
    for i in range(1, len(counts)):
        if totalCount - counts[i] > res[1]:
            res[0] = initial_machines[i]
            res[1] = totalCount - counts[i]
    return res


def repair_machine2(network, initial_machines):
    # We use union-find
    # maintain a dictionary: {root : (infected machine, # of machine fix)}
    # if the infected machines share the same root, # of machine fix to 0
    def find(i):
        while id[i] != i:
            id[i] = id[id[i]]
            i = id[i]
        return i

    def union(i, j):
        xset = find(i)
        yset = find(j)
        if xset != yset:
            if size[xset] > size[yset]:
                size[xset] += size[yset]
                id[yset] = xset
            else:
                size[yset] += size[xset]
                id[xset] = yset

    rows = len(network)
    cols = len(network[0])
    id = [i for i in range(rows)]
    size = [1 for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            if i == j and network[i][j] == 0:
                size[i] = 0
            elif network[i][j] == 1:
                union(i, j)
    table = {}
    for machine in initial_machines:
        root = find(machine)
        if root not in table:
            table[root] = [machine, size[root]]
        else:
            # handle the case where two infected machines in the same connected component
            # and there is no way we can fix them by fixing only one machine.
            table[root] = [machine, 0]
    res = [initial_machines[0], table[id[initial_machines[0]]][1]]
    for key in table.keys():
        if table[key][1] > res[1] or (table[key][0] < res[0] and table[key][1] == res[1]):
            res[0] = table[key][0]
            res[1] = table[key][1]
    return res


if __name__ == "__main__":
    network = [
        [1, 0, 1, 0, 0],
        [0, 1, 0, 1, 0],
        [1, 0, 1, 0, 0],
        [0, 1, 0, 1, 1],
        [0, 0, 0, 1, 1],
    ]
    initial_machines = [0, 4]
    assert repair_machine(network, initial_machines) == [4, 3]
    assert repair_machine2(network, initial_machines) == [4, 3]

    network = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ]
    initial_machines = [1, 0]
    assert repair_machine(network, initial_machines) == [0, 1]
    assert repair_machine2(network, initial_machines) == [0, 1]

    network = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ]
    initial_machines = [0, 1]
    assert repair_machine(network, initial_machines) == [0, 1]
    assert repair_machine2(network, initial_machines) == [0, 1]

    network = [
        [0, 0],
        [0, 0]
    ]
    initial_machines = [0, 1]
    assert repair_machine(network, initial_machines) == [0, 0]
    assert repair_machine2(network, initial_machines) == [0, 0]

    network = [
        [1, 0, 1, 0, 0],
        [0, 1, 0, 1, 0],
        [1, 0, 1, 0, 0],
        [0, 1, 0, 1, 1],
        [0, 0, 0, 1, 1],
    ]
    initial_machines = [0, 2]
    # Two machines in the same connected group should return 0 because fix one machine the other machine will
    # make the whole group infected again
    assert repair_machine(network, initial_machines) == [0, 0]
    assert repair_machine2(network, initial_machines) == [0, 0]
